Notes

when file is reading a raid group, read all the stripe into memory. Even if one block is written, then dirty
all the dbns, so that it can be writtin out again as a stripe. This also means dedupe should be aware of stripe
logic and make sure that the dbns of any stripe would have the same refcount/childrefcount.

dbns in a stripe can have refcount as 0. Remember, we have wafl style write, so we know for sure that the stripe
is written only once, so there is no problem as long as the blocks are not modified. This will however be an issue
because lets say we have refcounts of [0,2,3,2] for a stripe. We have a block free, this is called a stripe-hole.
The stripe hole can only filled by background scanners, wich we are offline.
** If we have [0,1,0,2], and we allow live writes, then we could have one file writing to block 0 and another file
trying to write to the third block creating race conditions.


Add autoload script as json input to reduce testing time.


1. There is an issue where wip has dbn as 1000 while inL0list we have dbn as 1001, and as we use get_buf() to search by start_fbn this discrepency is
not addressed. Essentially we could have a "start_fbn" block which some old dbn which is stale while wip (or its indirect) has something different.
We have to purge these stale blocks from memeory.
